#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Fri May 15 07:18:29 2020

@author: silasjimmy
"""

import random

class Card:
    '''
    Defines a card.
    '''
    def __init__(self, suit, value):
        self.suit = suit
        self.value = value
        
    def __str__(self):
        return " of ".join((self.value, self.suit))
    
class DiscardPile:
    '''
    Defines a discard pile.
    '''
    def __init__(self, other_cards=None):
        if other_cards:
            self.cards = other_cards
        else:
            self.cards = []
        
#    def get_cards(self):
#        '''
#        Gets the pile's cards
#        Returns (list of Card objects) the pile's cards.
#        '''
#        return self.cards
    
    def get_top_card(self):
        '''
        Returns (Card object) the top card in the pile.
        '''
        return self.cards[-1]
        
    def add_card(self, card):
        '''
        Adds a card to the pile.
        card (Card): The card to add to the pile.
        '''
        self.cards.append(card)
        
    def draw_card(self):
        '''
        Removes a card from the top of the pile.
        Returns (Card) a card.
        '''
        if len(self.cards) > 1:
            return self.cards.pop(-1)
#        
    def shuffle(self):
        '''
        Shuffles the pile.
        '''
        if len(self.cards) > 1:
            random.shuffle(self.cards)
#            
#    def is_empty(self):
#        '''
#        Checks if the pile has less than 2 cards to declare empty.
#        Returns True if it is, False otherwise.
#        '''
#        if len(self.cards) < 2:
#            return True
#        return False
            
class DrawPile(DiscardPile):
    '''
    Defines a draw pile
    '''
    def __init__(self, other_cards=None):
        super().__init__()
        if other_cards:
            self.cards = other_cards
        else:
            self.cards = [Card(s, v) for s in ["Spades", "Clubs", "Hearts", "Diamonds"] 
                                    for v in ["A", "2", "3", "4", "5", "6", "7", "8", 
                                    "9", "10", "J", "Q", "K"]]
            
    def deal_player_cards(self):
        '''
        Deals the players with 4 cards.
        Returns (list of Cards) cards dealt.
        '''
        return [self.cards.pop(i) for i in range(4)]
        
class Hand:
    '''
    Defines a hand
    '''
    def __init__(self, cards):
        self.cards = cards
        self.value = 0
    
    def get_cards(self):
        '''
        Returns (Card) the cards in the hand.
        '''
        return self.cards
#    
#    def add_card(self, card):
#        '''
#        Adds a card to the hand.
#        card (Card object): The card to add.
#        '''
#        self.cards.append(card)
#        
#    def drop_card(self, num):
#        '''
#        Removes a card at the position specified with num.
#        num (int): The position of the card to remove.
#        Returns (Card object) the card removed.
#        '''
#        dropped_card = self.cards.pop(num)
#        return dropped_card
#    
#    def get_hand_value(self):
#        '''
#        Returns (int) the value of the hand.
#        '''
#        self.calculate_hand_value()
#        return self.value
#        
#    def calculate_hand_value(self):
#        '''
#        Calculates the value of the hand.
#        '''
#        self.value = 0
#        card_values = set([card.value for card in self.cards])
#        for value in card_values:
#            if value in ["A", "K", "4", "7"]:
#                if value.isnumeric():
#                    self.value += int(value)
#                else:
#                    self.value += 10
#    
    def display_hand(self):
        '''
        Displays the hand.
        '''
        for i, card in enumerate(self.cards):
            print("({}) -> {}".format(i, card))
#            
#    def hand_over(self):
#        '''
#        Checks if the hand is over or not.
#        Returns True if it is, False otherwise.
#        '''
#        card_values = [card.value for card in self.cards]
#        card_values = set(card_values)
#        has_ak47 = False
#        if len(card_values) == 4:
#            for card_value in card_values:
#                if card_value in ["A", "K", "4", "7"]:
#                    has_ak47 = True
#                else:
#                    has_ak47 = False
#                    break
#            if has_ak47:
#                return True
#        return False
    
class Computer(Hand):
    '''
    Defines the computer's hand.
    '''
    def __init__(self, cards):
        super().__init__(cards)
        
#    def num_of_value_occurrences(self):
#        '''
#        Gets the number of occurrences of cards with the same value.
#        Returns (dict) each value with the number of occurrences.
#        '''
#        cards_occurrence = {}
#        for card in self.cards:
#            cards_occurrence[card.value] = len([c for c in self.cards if c.value == card.value])
#        return cards_occurrence
#    
#    def card_with_value(self, value):
#        '''
#        Gets the card with the specified value.
#        Returns (Card object) a card with the value specified.
#        '''
#        for index, card in enumerate(self.cards):
#            if card.value == value:
#                card_with_value = self.drop_card(index)
#                return card_with_value
#        
#    def play(self):
#        '''
#        Defines how the computer plays.
#        Returns (Card object) the card played.
#        '''
#        # Play if has a playable card
#        for index, card in enumerate(self.cards):
#            if card.value not in ["A", "K", "4", "7"]:
#                dropped = self.drop_card(index)
#                return dropped
#        # Play if has no playable card but a repeated card
#        value_occurrences = self.num_of_value_occurrences()
#        for value in value_occurrences:
#            if value_occurrences[value] > 1:
#                return self.card_with_value(value)

import os
from PIL import ImageTk, Image
import tkinter as tk

CARDS_FOLDER = os.path.join(os.getcwd(), "cards")

class Game(tk.Tk):
    def __init__(self):
        super().__init__()
        self.geometry("800x600")
        self.title("AK47")
        self.resizable(False, False)
        
        self.player_points = 0
        self.computer_points = 0
        self.player_points_string = tk.StringVar()
        self.computer_points_string = tk.StringVar()
        
        self.create_game_screen()
        
    def create_game_screen(self):
        '''
        Creates the game screen.
        '''
        # Create the game screen
        self.game_screen = tk.Frame(self, width=800, height=600, bg="green")
        self.game_screen.pack_propagate(0)
        
        # Create the points labels
        self.player_points_string.set("Player points: " + str(self.player_points))
        self.computer_points_string.set("Computer points: " + str(self.computer_points))
        self.player_points_label = tk.Label(self.game_screen, textvar=self.player_points_string, font="Arial 15 bold", fg="white", bg="green")
        self.comp_points_label = tk.Label(self.game_screen, textvar=self.computer_points_string, font="Arial 15 bold", fg="white", bg="green")
        
        # Create the draw pile, hands and discard pile
        self.draw_pile = DrawPile()
        self.draw_pile.shuffle()
        self.player = Hand(self.draw_pile.deal_player_cards())
        self.computer = Computer(self.draw_pile.deal_player_cards())
        self.discard_pile = DiscardPile()
        self.discard_pile.add_card(self.draw_pile.draw_card())
        
        # Display the cards and points labels
        self.display_computer_cards()
        self.display_draw_pile()
        self.display_discard_pile()
        self.display_player_cards()
        self.player_points_label.pack(side=tk.RIGHT, anchor=tk.S, padx=(0, 20), pady=(0, 15))
        self.comp_points_label.pack(side=tk.LEFT, anchor=tk.N, padx=(20, 0), pady=(15, 0))
        
        self.game_screen.pack(side=tk.LEFT, anchor=tk.N)
        
    def display_computer_cards(self, reveal_cards=False):
        '''
        Displays the computer cards.
        '''
        computer_cards = self.computer.get_cards()
        if reveal_cards:
            card_image_names = [self.card_png_name(card) for card in computer_cards]
            self.computer_card_images = [ImageTk.PhotoImage(Image.open(CARDS_FOLDER + "/" + card_name)) for card_name in card_image_names]
        else:
            self.computer_card_images = [ImageTk.PhotoImage(Image.open(CARDS_FOLDER + "/back.png")) for i in range(len(computer_cards))]
        self.computer_card_image_labels = [tk.Label(self.game_screen, image=card_image) for card_image in self.computer_card_images]
        
        # Centering the cards horizontally
        card_width = self.computer_card_image_labels[0].winfo_reqwidth()
        card_spacing = 30
        cards_length = ((len(computer_cards) - 1) * card_spacing) + card_width
        remaining_window_space = self.game_screen.winfo_reqwidth() - cards_length
        x_start = remaining_window_space / 2
        
        for index, card_image_label in enumerate(self.computer_card_image_labels):
            pad = index * card_spacing
            card_image_label.place(x=x_start+pad, y=50)
    
    def display_draw_pile(self):
        '''
        Displays the draw pile.
        '''
        self.draw_pile_png = ImageTk.PhotoImage(Image.open(CARDS_FOLDER + "/back.png"))
        self.draw_pile_label = tk.Label(self.game_screen, image=self.draw_pile_png)
        self.draw_pile_label.bind("<Button-1>", self.draw_card)
        
        card_height = self.draw_pile_label.winfo_reqheight()
        occupied_space = (card_height * 2) + 100
        remaining_window_space = self.game_screen.winfo_reqheight() - occupied_space
        y = card_height + (remaining_window_space / 2)
        
        self.draw_pile_label.place(x=100, y=y)
    
    def display_discard_pile(self):
        '''
        Displays the discard pile.
        '''
        top_card_png_name = self.card_png_name(self.discard_pile.get_top_card())
        self.discard_pile_png = ImageTk.PhotoImage(Image.open(CARDS_FOLDER + "/" + top_card_png_name))
        self.discard_pile_label = tk.Label(self.game_screen, image=self.discard_pile_png)
        self.discard_pile_label.bind("<Button-1>", self.pick_discarded_card)
        
        card_height = self.draw_pile_label.winfo_reqheight()
        card_width = self.discard_pile_label.winfo_reqwidth()
        occupied_space = (card_height * 2) + 100
        remaining_window_space = self.game_screen.winfo_reqheight() - occupied_space        
        x = self.game_screen.winfo_reqwidth() - (card_width + 100)
        y = card_height + (remaining_window_space // 2)
        
        self.discard_pile_label.place(x=x, y=y)
    
    def display_player_cards(self):
        '''
        Displays the player cards.
        '''
        player_cards = self.player.get_cards()
        card_image_names = [self.card_png_name(card) for card in player_cards]
        self.player_card_images = [ImageTk.PhotoImage(Image.open(CARDS_FOLDER + "/" + card_name)) for card_name in card_image_names]
        self.player_card_image_labels = [tk.Label(self.game_screen, image=card_image) for card_image in self.player_card_images]
        
        # Centering the cards horizontally
        card_width = self.player_card_image_labels[0].winfo_reqwidth()
        card_height = self.player_card_image_labels[0].winfo_reqheight()
        card_spacing = 30
        cards_length = ((len(player_cards) - 1) * card_spacing) + card_width
        remaining_window_space = self.game_screen.winfo_reqwidth() - cards_length
        x_start = remaining_window_space / 2
        y_start = self.game_screen.winfo_reqheight() - (card_height + 50)
        
        for index, card_image_label in enumerate(self.player_card_image_labels):
            self.make_dragable(card_image_label)
            pad = index * card_spacing
            card_image_label.place(x=x_start+pad, y=y_start)
    
    def card_png_name(self, card):
        '''
        Creates the card's png image name.
        card (Card): A card.
        Returns (str) the name of the card's image name.
        '''
        return card.suit + card.value + ".png"
    
    def draw_card(self, event):
        '''
        Adds a card from the draw pile to the hand.
        '''
        print("Draw a card from the draw pile.")
        
    def pick_discarded_card(self, event):
        '''
        Adds a card from the discard pile to the hand.
        '''
        print("Draw the top card from the discard pile.")
    
    def on_drag_start(self, event):
        '''
        Triggered when the card is clicked.
        '''
        widget = event.widget
        widget._drag_start_x = event.x
        widget._drag_start_y = event.y
        
        # Card's original coords
        self.original_x = widget.winfo_x()
        self.original_y = widget.winfo_y()
        
    def on_drag_motion(self, event):
        '''
        Triggered when the card is dragged across the window.
        '''
        widget = event.widget
        x = widget.winfo_x() - widget._drag_start_x + event.x
        y = widget.winfo_y() - widget._drag_start_y + event.y
        
        # Define the window boundary of the drag and drop
        x_boundary = 800 - widget.winfo_width()
        y_boundary = 600 - widget.winfo_height()
        if (x > 0 and x < x_boundary) and (y > 0 and y < y_boundary):
            widget.place(x=x, y=y)
            
    def on_drag_release(self, event):
        widget = event.widget
        x = widget.winfo_x()
        y = widget.winfo_y()
        
        if (x > 546 and x < 690) and (y > 147 and y < 353):
            print("Discard")
            widget.place(x=self.original_x, y=self.original_y)
        else:
            print("Return to base")
            widget.place(x=self.original_x, y=self.original_y)
            
    def make_dragable(self, widget):
        '''
        Makes the card draggable.
        '''
        widget.bind("<Button-1>", self.on_drag_start)
        widget.bind("<B1-Motion>", self.on_drag_motion)
        widget.bind("<ButtonRelease-1>", self.on_drag_release)
        
game = Game()
game.mainloop()